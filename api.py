from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import asyncio
import json
import re
from datetime import datetime
from langchain_core.messages import HumanMessage
from reflexion_graph import app as langraph_app
from langchain_google_genai import ChatGoogleGenerativeAI
import requests
from bs4 import BeautifulSoup
import aiohttp
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Initialize FastAPI app
app = FastAPI(
    title="Legal Advisor AI Agent API",
    description="AI-powered legal analysis with step-by-step thinking and link summaries",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request/Response models (unchanged except for clarity)
class LegalCaseRequest(BaseModel):
    case_description: str
    user_id: Optional[str] = None

class LinkSummary(BaseModel):
    url: str
    title: str
    summary: str
    status: str

class ThinkingStep(BaseModel):
    step_number: int
    step_name: str
    description: str
    details: str
    timestamp: str

class LegalAnalysisResponse(BaseModel):
    case_name: str
    analysis_date: str
    thinking_steps: List[ThinkingStep]
    final_answer: str
    references: List[str]
    link_summaries: List[LinkSummary]
    total_steps: int
    processing_time: float

class FormattedAnalysisResponse(BaseModel):
    case_name: str
    analysis_date: str
    thinking_steps: List[ThinkingStep]
    formatted_analysis: str  # Now contains HTML generated by Gemini
    references: List[str]
    link_summaries: List[LinkSummary]
    total_steps: int
    processing_time: float

# Web scraping function (unchanged)
async def get_link_summary(url: str) -> Optional[LinkSummary]:
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    html = await response.text()
                    soup = BeautifulSoup(html, 'html.parser')
                    title = soup.find('title').get_text().strip() if soup.find('title') else "No title found"
                    meta_desc = soup.find('meta', attrs={'name': 'description'})
                    summary = meta_desc['content'][:200] + "..." if meta_desc and meta_desc.get('content') and len(meta_desc['content']) > 200 else (meta_desc['content'] if meta_desc else "")
                    if not summary:
                        paragraphs = soup.find_all('p')
                        for p in paragraphs:
                            text = p.get_text().strip()
                            if len(text) > 50:
                                summary = text[:200] + "..." if len(text) > 200 else text
                                break
                        if not summary:
                            summary = "Content summary not available"
                    return LinkSummary(url=url, title=title, summary=summary, status="success")
                return None
    except Exception:
        return None

# Extract thinking steps (unchanged)
def extract_thinking_steps(response_messages) -> List[ThinkingStep]:
    steps = []
    step_counter = 1
    for i, message in enumerate(response_messages):
        if hasattr(message, 'tool_calls') and message.tool_calls:
            for tool_call in message.tool_calls:
                if tool_call['name'] == 'AnswerQuestion':
                    steps.append(ThinkingStep(
                        step_number=step_counter,
                        step_name="Initial Analysis",
                        description="AI analyzes the case and provides initial legal assessment",
                        details=f"Generated initial answer with {len(tool_call['args'].get('search_queries', []))} search queries",
                        timestamp=datetime.now().isoformat()
                    ))
                    step_counter += 1
                elif tool_call['name'] == 'ReviseAnswer':
                    steps.append(ThinkingStep(
                        step_number=step_counter,
                        step_name="Research & Revision",
                        description="AI revises the analysis based on critique",
                        details=f"Revised with {len(tool_call['args'].get('search_queries', []))} new queries",
                        timestamp=datetime.now().isoformat()
                    ))
                    step_counter += 1
    return steps

# Extract references (unchanged)
def extract_references(response) -> List[str]:
    references = []
    if response and hasattr(response[-1], 'tool_calls') and response[-1].tool_calls:
        for tool_call in response[-1].tool_calls:
            if tool_call['name'] == 'ReviseAnswer':
                references.extend(tool_call['args'].get('references', []))
    return [ref for ref in references if ref.startswith(('http://', 'https://'))]

# New function to generate HTML using Gemini
def generate_html_from_analysis(analysis_text: str) -> str:
    """Convert plain text analysis to HTML using Gemini."""
    gemini_llm = ChatGoogleGenerativeAI(model="gemini-1.5-pro")  # Use a suitable Gemini model
    prompt = f"""
    Convert the following legal analysis text into a well-formatted HTML document suitable for a professional legal report. Use appropriate HTML tags:
    - Use <h1> for the case name, <h2> for section headers (e.g., Executive Summary, Law Applicable), <p> for paragraphs.
    - Use <strong> for bold text (replace **text** with <strong>text</strong>).
    - Use <ul><li> for bullet points (replace - with <li> and group with <ul>).
    - Ensure proper nesting and structure.
    - Do not include any external CSS or JavaScript; only return pure HTML.

    Text:
    {analysis_text}
    """
    response = gemini_llm.invoke([HumanMessage(content=prompt)])
    html_content = response.content.strip()
    # Ensure the response is valid HTML (basic sanitization)
    if html_content.startswith('<') and html_content.endswith('>'):
        return html_content
    return f"<div>{html_content}</div>"  # Fallback wrapper if Gemini returns plain text

# Main analysis endpoint (updated to include HTML generation)
@app.post("/analyze-case")
async def analyze_legal_case(request: LegalCaseRequest):
    start_time = datetime.now()
    try:
        # Invoke the Langraph agent
        response = langraph_app.invoke([HumanMessage(content=request.case_description)])
        
        # Extract thinking steps and references
        thinking_steps = extract_thinking_steps(response)
        references = extract_references(response)
        
        # Get final answer from the last message
        final_answer = ""
        if response and hasattr(response[-1], 'tool_calls') and response[-1].tool_calls:
            final_answer = response[-1].tool_calls[0]["args"].get("answer", "")
        
        # Generate HTML-formatted analysis using Gemini
        formatted_analysis = generate_html_from_analysis(final_answer)
        
        # Generate link summaries for successful references
        link_summaries = []
        successful_references = []
        tasks = [get_link_summary(ref) for ref in references if ref.startswith(('http://', 'https://'))]
        summaries = await asyncio.gather(*tasks)
        for summary in summaries:
            if summary:
                link_summaries.append(summary)
                successful_references.append(summary.url)
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return LegalAnalysisResponse(
            case_name=f"Case Analysis - {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            analysis_date=datetime.now().isoformat(),
            thinking_steps=thinking_steps,
            final_answer=final_answer,
            references=successful_references,
            link_summaries=link_summaries,
            total_steps=len(thinking_steps),
            processing_time=processing_time
        )
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")

# Updated formatted analysis endpoint to use pre-generated HTML
@app.post("/analyze-case-formatted")
async def analyze_legal_case_formatted(request: LegalCaseRequest):
    start_time = datetime.now()
    try:
        # Invoke the Langraph agent
        response = langraph_app.invoke([HumanMessage(content=request.case_description)])
        
        # Extract thinking steps and references
        thinking_steps = extract_thinking_steps(response)
        references = extract_references(response)
        
        # Get final answer from the last message
        final_answer = ""
        if response and hasattr(response[-1], 'tool_calls') and response[-1].tool_calls:
            final_answer = response[-1].tool_calls[0]["args"].get("answer", "")
        
        # Generate HTML-formatted analysis using Gemini
        formatted_analysis = generate_html_from_analysis(final_answer)
        
        # Generate link summaries for successful references
        link_summaries = []
        successful_references = []
        tasks = [get_link_summary(ref) for ref in references if ref.startswith(('http://', 'https://'))]
        summaries = await asyncio.gather(*tasks)
        for summary in summaries:
            if summary:
                link_summaries.append(summary)
                successful_references.append(summary.url)
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return FormattedAnalysisResponse(
            case_name=f"Case Analysis - {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            analysis_date=datetime.now().isoformat(),
            thinking_steps=thinking_steps,
            formatted_analysis=formatted_analysis,  # Pre-formatted HTML
            references=successful_references,
            link_summaries=link_summaries,
            total_steps=len(thinking_steps),
            processing_time=processing_time
        )
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")

# Other endpoints (unchanged)
@app.get("/analyze-case")
async def analyze_legal_case_get(case_description: str = "Test case for API verification"):
    request = LegalCaseRequest(case_description=case_description)
    start_time = datetime.now()
    response = langraph_app.invoke(request.case_description)
    thinking_steps = extract_thinking_steps(response)
    references = extract_references(response)
    final_answer = response[-1].tool_calls[0]["args"].get("answer", "") if response and hasattr(response[-1], 'tool_calls') else ""
    processing_time = (datetime.now() - start_time).total_seconds()
    return {
        "message": "GET endpoint working - use POST for full functionality",
        "case_description": case_description,
        "final_answer_preview": final_answer[:200] + "..." if len(final_answer) > 200 else final_answer,
        "processing_time": processing_time,
        "note": "This is a test endpoint. Use POST /analyze-case with JSON body for full analysis."
    }

@app.get("/test")
async def test_endpoint():
    return {
        "message": "API is working!",
        "endpoints": {
            "POST /analyze-case": "Submit legal case for analysis",
            "POST /analyze-case-formatted": "Get formatted analysis for separate page display",
            "GET /analyze-case": "Test endpoint with query parameter",
            "GET /api/health": "Health check",
            "GET /docs": "API documentation"
        },
        "timestamp": datetime.now().isoformat()
    }

@app.get("/")
async def home(request: Request):
    return {
        "message": "Legal Advisor AI Agent API",
        "description": "AI-powered legal analysis with step-by-step thinking and link summaries",
        "endpoints": {
            "POST /analyze-case": "Submit legal case for analysis",
            "POST /analyze-case-formatted": "Get formatted analysis for separate page display",
            "GET /analyze-case": "Test endpoint with query parameter",
            "GET /api/health": "Health check",
            "GET /docs": "API documentation"
        },
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
